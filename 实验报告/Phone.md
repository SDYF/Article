<head>
<style>
table {font-family: "Source Code Pro";}
</style>
</head>

###<center>统计话费实验报告</center>
####问题描述</br>
&emsp;&emsp;程序能够完成如下功能：统计给定文件中的用户通话时间从而计算出话费，输入输出均为文件输入输出，输入文件为`records.txt`，输出文件为`cost.txt`.
####实验内容  
&emsp;&emsp;程序中使用的主要数据结构是散列表`fee[]`,散列函数为`h(K)=K`.由于需要减少运行时间，因此采用空间换时间的方式，开辟了一个大小为1亿的long数组作为散列表，以完全避免冲突.  
　&emsp;同样，为了减少运行时间，程序只有main函数。
　&emsp;算法流程：每次从`records.txt`中读取一行数据到字符数组`record`中，直至文件结束.接着按照输入文件格式，以电话号码的第3-10位作为关键码值$K$，用变量`index`记录.然后用`record`的第13-16位计算通话用时，再将其按进一法转化为以分钟为单位.同时，用`40 - (record[12] - 48) * 20`区分主、被叫及其每分钟话费，以避免使用if进行判断，对于运行时间有微弱的减少.接着用`phone_cost`记录单行数据的话费，用变量`i`记录不同号码的数量，数组`a[]`记录不同号码的$K$值.如果`fee[index]`为0，则说明该号码未被记录过，i值加一并记录关键码；若不为0，则说明已经被记录过，只需将`phone_cost`的值加上即可.数据输出部分则通过数组`a[]`记录的关键码值对`fee[]`进行查询，以避免遍历带来的运行时间的大大增加.
　&emsp;算法的空间复杂度为$O(10^{m-3}+p)$，其中$m$为电话号码位数，一般为11，$p$为不同电话号码的总数.时间复杂度为$O(n)$，$n$为记录的总数.
####实验结果  
&emsp;&emsp;手动计算部分数据结果如下：
- 号码：13955191490
  |记录|通话时间/分钟|话费/分|
  |:---:|:---------:|:--:|
  |13955191490010225JQHK|4|80|
  |13955191490010545DNWK|10|200|
  |13955191490010554LPLD|10|200|
  |13955191490010031JOGP|1|20|
  |13955191490010365BISH|7|140|
  |13955191490010315WPFD|6|120|
  |13955191490010431LZTL|8|160|
  |13955191490000345OZNV|6|240|
  |13955191490010593YRKX|10|200|
  |13955191490000432GWSC|8|320|
  |13955191490010373XKEQ|7|140|
  |13955191490000272EQPW|5|200|
  |13955191490000000XJCR|0|0|
  |13955191490010526WQIT|9|180|
  总话费：2200分
  输出为：1395519149000002200，正确

####讨论与结论
&emsp;&emsp;在最开始时，我尝试用C++写，总时间约为1.7s，测试发现，string类的各种函数虽然使用方便，但是运行过程复杂，使得运行时间过长。用C重写之后，运行时间减少至0.2s.接着发现对时间影响最大的是通话时间和电话号码的计算.我开始尝试用循环+pow进行计算，但是由于浮点计算精度以及运行时间的问题，舍弃了该方案，而采用最基础的算法直接计算，使得运行时间减少了0.2s.散列函数采用`h(K)=K`的原因也是最初的计算地址的方法过于复杂，而且需要解决冲突，使得运行时间大大增加.最后，为了加快运行速度，编译时还开启了O2优化.